# 关注点

1. 性能监测工具（enableDebugTools)

   > ng.profiler.timeChangeDetection({record: true})可以触发变更检测，并记录平均每次tick的时间

2. preserveWhitespaces

   删除空白字符，默认为preserveWhitespaces:false不保留

   ```
   aot可以配置：
   tsconfig.json
   "angularCompilerOptions": {
   	"preserveWhitespaces": false,
   }
   
   jit:
   bootstrapModule(AppModule, { preserveWhitespaces: false})
   ```

3. 异步发送多个请求后合并结果会导致tick几次？

   > 批量操作通过this._ngZone.runOutsideAngular完成计算后再tick?
   >
   > 复杂计算请移到runOutsideAngular内部

4. onPush & markForCheck & changeDefects & detach &retach

   > immutable

   > markForCheck是否会导致父级更新？比如父级onPush，input未更新，那么子级markForCheck时父级是否进行更新？
   >
   > changeDefects是否是只更新当前组件及子组件？

5. ngxs注册多个监听时，只更新一处是否会倒致多处监听触发？(己验证)

   > 注意：ngxs每次dispatch都会倒致一次tick， ngxs dispatch会倒致一次postMessage
   >
   > dispatch里面传数组时，每个action倒致一次tick

   ```
   select方法在使用时最好使用@Selector定义好的函数，这样会缓存，否则只要有变化就触发
   //下面的写法在每次有dispatch	action时都会触发
   this.store.select(state => state).subscibe(state => console.log('=====>', state))
   
   //下面的写法只有corpType发生变化时才触发临听
   @Select(CorpInfoState.companyType) companyType$: Observable<number>
   corpType$.subscribe(companyType => console.log('=======>', companyType))
   
   this.store.select(CorpInfoState.corpInfo)等效于下面的：
   @Select(CorpInfoState.corpInfo) corpInfo$: Observable<number>
   corpType$.subscribe(corpInfo => console.log('=======>', corpInfo))
   
   dispatch companyType时companyType及其父对象corpInfo都变了，所以两个都有触发
   
   dispatch corpType时只有父对象corpInfo变了，所以只触发corpInfo的监听
   dispatch accountType时都没有变化，一个监听都不触发
   ```

6. destroy时监听destroyUtil是否会倒致一次tick?

7. form存在多个监听时，能否做到只有当前值修改了才触发（默认一处修改全部触发）

8. trackBy

9. 部分组件被render多次（oninit触发多次，能否加一些工具方法来认别出组件存在多次实例化？）

10. pipe 

    > 异步pipe不会比较值，只要next就会执行
    >
    > 普通pipe只要有变更检测就会执行

    ```
    使用pure pipe(pure pipe会缓存结果):
    @Pipe({
        name: "util",
        pure: true
    })
    ```

11. 模块表达示优化

    > 减少函数的调用
    >
    > 变更检测时运行模块函数会运行模块中的函数，变更检测后的值校验会再次运行对应的函数生成新的值并对比新老值

12. 静态内容cache (将公用模板统一query出来保存并调用)

13. 用代码代替ngFor

    ```
    <tr *ngFor="let item of items; trackBy: trackById;" class="h-12">
      <td>
        <span>{{ item.label }}</span>
      </td>
    </tr>
    
    代码是知道什么时候去执行的，用ngFor的话模块函数执行时就会执行一遍
    <tbody>
      <ng-container #itemsContainer></ng-container>
    </tbody>
    <ng-template #item let-item="item">
      <tr class="h-12">
        <td>
          <span>{{ item.label }}</span>
        </td>
      </tr>
    </ng-template>
    
    for (let n = start; n <= end; n++) {
        this.container.createEmbeddedView(this.template, {
          item: {
            label: Math.random()
          }
        });
    }
    ```

14. 虚拟滚动

15. webworker

    ```
    费时计算webworker
    ```

16. 懒加载 & preload

17. Treeshake