# 日期

### Date

> 不带时区，不方便计算

### Calendar

> Calendar表示一个特定的时间点，默认代表当前时间
>
> 操作日期较方便，能够按单位加减日期，可以比较日期

``` java
//加减是同一个操作，减是给负值
calendar.add(Calendar.YEAR, 1);
logger.info("year:" + calendar.get(Calendar.YEAR)); //年
calendar.add(Calendar.MONTH, 1);
logger.info("month:" + calendar.get(Calendar.MONTH)); //月
calendar.add(Calendar.DATE, 1);
logger.info("day:" + calendar.get(Calendar.DATE)); //月的天

// calendar也可以设置时区
calendar.setTimeZone(gmtTimeZone);

/**
* 两个不同的calendar,设置不同的时区，设置同一个时间，转成日期后的Date是一样的
* 感觉Calendar里面的时区作用和SimpleDataFormat一样，对日期本身没有影响
* 可能对星期的开始有影响
*/
TimeZone gmtTimeZone = TimeZone.getTimeZone("Etc/GMT+9");
TimeZone isoTimeZone = TimeZone.getTimeZone("GMT+00:00");
Calendar calendar = Calendar.getInstance();
calendar.clear();
calendar.setTimeZone(gmtTimeZone);
calendar.set(2020, 5, 8 , 10, 10, 10);

Calendar calendar2 = Calendar.getInstance();
calendar2.clear();
calendar2.setTimeZone(isoTimeZone);
calendar2.set(2020, 5, 8 , 10, 10, 10);

Date date = calendar.getTime();
Date isoDate = calendar2.getTime();
```

### SimpleDataFormat

``` java
/***
 * 年：       y
 * 月：       M       MM 01       MMM 一月
 * 日：       d
 * 时：       H/h     H 24小时      h 12小时制
 * 分：       m
 * 秒：       s
 * 毫秒：      S
 * 星期：      E
 * 年中的天： D
 * 时区：      Z
 */
SimpleDateFormat sdf1 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z");
SimpleDateFormat sdf2 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z");
sdf2.setTimeZone(TimeZone.getTimeZone("America/New_York"));

logger.info("simple date format: " + sdf1.format(date));
logger.info("simple date format with timezone new york: " + sdf2.format(date));

//同一个日期，SimpleDateFormat配不同的时区，parse出来的日期是一样的，可见时区只在format时起了作用
logger.info("simpate date parse:" + sdf1.parse("2020-05-08 15:20:20 +0800"));
logger.info("simpate date parse with timezone new york:" + sdf2.parse("2020-05-08 15:20:20 +0800"));
```

### TimeZone

> 表示一个时区

``` java
TimeZone.getTimeZone("Asia/Shanghai") //根据ID名获取时区
```

### ZoneId

### LocalDateTime、LocalDate、LocalTime

> LocalDateTime = LocalDate(日期1990-0101) + LocalTime(时间10:10:10)
>
> 根据当前时刻毫秒数与时区偏移量算出对应的LocalDate与LocalTime
>
> 本质上它内部没有持有时区，在初始化时用时区计算出偏移量，但是并没有存时区

``` java
public static LocalDateTime now(Clock clock) {
  Objects.requireNonNull(clock, "clock");
  Instant now = clock.instant();//当前时刻
  ZoneOffset offset = clock.getZone().getRules().getOffset(now);//时区的偏移
  return ofEpochSecond(now.getEpochSecond(), now.getNano(), offset);//秒、纳秒、时区偏移
}

public static LocalDateTime ofEpochSecond(long epochSecond, int nanoOfSecond, ZoneOffset offset) {
  Objects.requireNonNull(offset, "offset");
  ChronoField.NANO_OF_SECOND.checkValidValue((long)nanoOfSecond);
  long localSecond = epochSecond + (long)offset.getTotalSeconds();//GMT时刻的秒+时区的偏移秒
  long localEpochDay = Math.floorDiv(localSecond, 86400);
  int secsOfDay = Math.floorMod(localSecond, 86400);
  LocalDate date = LocalDate.ofEpochDay(localEpochDay);//根据偏移的天算出日期
  LocalTime time = LocalTime.ofNanoOfDay((long)secsOfDay * 1000000000L + (long)nanoOfSecond);//根据依稀除下秒算出时间
  return new LocalDateTime(date, time);
}
```

### ZonedDateTime

> 和OffsetDateTime相比多了夏令时
>
> 同mysql的timestamp一样，同一个时间点存在数据库，设置不同的时区查出来的结果不一样,对于ZonedDateTime表示的时间就算在同一个时区它是会变的
>
> 内部变是一个LocalDateTime，并持有一个时区

``` java
public static LocalDateTime now(Clock clock) {
  Objects.requireNonNull(clock, "clock");
  final Instant now = clock.instant();  // called once
  ZoneOffset offset = clock.getZone().getRules().getOffset(now);
  return ofEpochSecond(now.getEpochSecond(), now.getNano(), offset);
}

private static ZonedDateTime create(long epochSecond, int nanoOfSecond, ZoneId zone) {
  ZoneRules rules = zone.getRules();
  Instant instant = Instant.ofEpochSecond(epochSecond, nanoOfSecond);  // TODO: rules should be queryable by epochSeconds
  ZoneOffset offset = rules.getOffset(instant);
  //实例化一个LocalDateTime
  LocalDateTime ldt = LocalDateTime.ofEpochSecond(epochSecond, nanoOfSecond, offset);
  return new ZonedDateTime(ldt, offset, zone);
}
```



### OffsetDateTime

> 本质上也没有存时区，它将对应时区的偏移存了下来
>
> 内部也是一个LocalDateTime

``` java
public static OffsetDateTime now(Clock clock) {
  Objects.requireNonNull(clock, "clock");
  final Instant now = clock.instant();  // called once
  return ofInstant(now, clock.getZone().getRules().getOffset(now));
}

public static OffsetDateTime ofInstant(Instant instant, ZoneId zone) {
  Objects.requireNonNull(instant, "instant");
  Objects.requireNonNull(zone, "zone");
  ZoneRules rules = zone.getRules();
  ZoneOffset offset = rules.getOffset(instant);
  LocalDateTime ldt = LocalDateTime.ofEpochSecond(instant.getEpochSecond(), instant.getNano(), offset);
  return new OffsetDateTime(ldt, offset);
}
```



